#include <logs/logs.h>
#include <misc/paths.h>
#include <misc/files.h>
#include <misc/tdf.h>
#include "modinfo.h"
#include "mods.h"

namespace TA3D
{
    ModInfo::ModInfo(const int ID, const QString &name, const QString &version, const QString &author, const QString &comment, const QString &url)
		: ID(ID), name(name), version(version), author(author), comment(comment), url(url), installed(false), availableUpdate(false)
    {
    }

    ModInfo::ModInfo(const QString &info)
    {
        parse(info);
    }

    void ModInfo::parse(const QString &info)
    {
        QStringList params;

        QString::size_type pos = 0;
        while((pos = info.indexOf("\"", pos)) != -1)
        {
            ++pos;
            QString p;
            while(pos < info.size() && info[pos] != '"')
            {
                if (info[pos] == '\\' && pos + 1 < info.size())
                {
                    ++pos;
					if (info[pos] == 'n')
                        p += '\n';
					else
                        p += info[pos];
                }
				else if (info[pos] != '\r')
                    p += info[pos];
                ++pos;
            }
            ++pos;
            params.push_back(p);
        }

        if (params.size() != 6)     // If there is not the expected number of parameters, then we can't trust this information
        {
            *this = ModInfo();
            return;
        }

        ID = params[0].toInt();
        version = params[1];
        name = params[2];
        url = params[3];
        author = params[4];
        comment = params[5];
		installed = false;
		availableUpdate = false;
    }

    void ModInfo::read(const QString &modName)
    {
		name = modName;
        const QString &filename = getPathToMod() + Paths::Separator + "info.mod";

		availableUpdate = false;

		if (!Paths::Exists(filename))
		{
			ID = -1;
			name = modName;
			version = QString();
			author = QString();
			comment = QString();
			url = QString();
			installed = false;
			return;
		}

		TDFParser file(filename, false, false, false, true);
        ID = file.pullAsInt("mod.ID", -1);
        name = file.pullAsString("mod.name");
        version = file.pullAsString("mod.version");
        author = file.pullAsString("mod.author");
        comment = file.pullAsString("mod.comment");
        comment.replace("\n", "\\n");
        url = file.pullAsString("mod.url");
		installed = file.pullAsBool("mod.installed", false);
    }

	QString ModInfo::getPathToMod() const
	{
        QString path = Paths::Resources + "mods" + Paths::Separator + cleanStringForPortablePathName(name);
		return path;
	}

    void ModInfo::write()
    {
        if (name.isEmpty() || ID == -1)       // Don't save empty data
            return;

        QString filename = getPathToMod() + Paths::Separator + "info.mod";
		QString tmp(comment);
		tmp.replace("\n", "\\n");

        QString file;
        file += "// TA3D Mod info file\n"
                "// autogenerated by ta3d\n"
                "[mod]\n"
                "{\n"
                "    ID = " + QString::number(ID) + ";\n"
                "    name = " + name + ";\n"
                "    version = " + version + ";\n"
                "    author = " + author + ";\n"
                "    comment = " + tmp + ";\n"
                "    url = " + url + ";\n"
                "    installed = " + installed + ";\n"
                "}";
		Paths::MakeDir(Paths::ExtractFilePath(filename, false));
        Paths::Files::SaveToFile(filename, file);
    }

	void ModInfo::setInstalled(bool b)
	{
		installed = b;
		write();

		Mods::instance()->update();
	}

	void ModInfo::uninstall()
	{
		if (ID < 0 || !installed)	return;

		LOG_INFO(LOG_PREFIX_RESOURCES << "uninstalling mod '" << name << "'");

		QString modpath = getPathToMod();
		Paths::RemoveDir(modpath);
		installed = false;
		write();

		LOG_INFO(LOG_PREFIX_RESOURCES << "mod uninstalled");
	}

    QString ModInfo::cleanStringForPortablePathName(const QString &s)
	{
		QString result;
		result.reserve(s.size());
		for(uint32 i = 0 ; i < s.size() ; ++i)
		{
            switch(s[i].toLatin1())
			{
			case ':':
			case '/':
			case '\\':
			case '?':
			case '*':
			case '<':
			case '>':
			case '|':
				break;
			default:
                result += s[i];
			};
		}

		return result;
	}
}
